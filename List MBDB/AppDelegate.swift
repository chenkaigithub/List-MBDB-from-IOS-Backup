//
//  AppDelegate.swift
//  List manifest.MBDB
//
//  Program for parsing the Backup files of IOS
//   generated by iTunes for iPad and iPhone
//  Extracting of stored files which could not be recoverd otherwise
//  see what is covered under the hood of IOS
//
//  There is a python script which inspired me to the program
//   see <https://gist.github.com/aliou/4448630>
//
//  learned a lot about crypting and retrieving information
//
//  Created by Erich KÃ¼ster on 17.05.15.
//  Copyright (c) 2015 Erich Kuester. All rights reserved.
//

import Cocoa
import Foundation

class ItemProperty: NSObject {
    var propertyName: String? = String()
    var propertyValue: String? = String()
}

class FileInfo: NSObject {
    var domain: NSData? = NSData()
    var domainString = String()
    var pathID: NSData? = NSData()
    var pathIDString = String()
    var linkTarget = String()
    var SHA1: String = String()
    var type = String()
    var mtime = NSDate()
    var atime = NSDate()
    var ctime = NSDate()
    var itemProperties: Array<ItemProperty> = []

    func infoStrings() {
        domainString = NSString(data:domain!, encoding:NSUTF8StringEncoding) as! String
        if (pathID != nil) {
            pathIDString = NSString(data:pathID!, encoding:NSUTF8StringEncoding) as! String
        }
    }

    func SHA1fromData() {
        let dataSHA1 = NSMutableData()
        dataSHA1.appendData(domain!)
        dataSHA1.appendData(NSData(bytes: [0x2d] as [UInt8], length: 1))
        dataSHA1.appendData(pathID!)
        var digest = [UInt8](count:Int(CC_SHA1_DIGEST_LENGTH), repeatedValue: 0)
        CC_SHA1(dataSHA1.bytes, CC_LONG(dataSHA1.length), &digest)
        var hexString = ""
        for byte in digest {
            hexString += String(format:"%02x", byte)
        }
        SHA1 = hexString
    }
}

@NSApplicationMain
class AppDelegate: NSObject, NSApplicationDelegate, NSComboBoxDataSource, NSTableViewDataSource, NSTableViewDelegate {

    @IBOutlet weak var window: NSWindow!
    @IBOutlet weak var backupTableView: NSTableView!
    @IBOutlet weak var selectTextField: NSTextField!
    @IBOutlet var statusTextView: NSTextView!
    @IBOutlet weak var domainComboBox: NSComboBox!

    var directoryURL: NSURL = NSURL()
    var userDirectoryURL: NSURL = NSURL()
    var backupItems: Array<FileInfo> = []
    var filteredItems: Array<FileInfo> = []
    var domainItems: Array<FileInfo> = []
    // offset into nsdata object
    var offset = 0

    func applicationDidFinishLaunching(aNotification: NSNotification) {
        // Insert code here to initialize your application
        //domainComboBox.numberOfVisibleItems = 10
        statusTextView.font = NSFont(name: "Consolas", size: 14)
    }

    func applicationWillTerminate(aNotification: NSNotification) {
        // Insert code here to tear down your application
    }

    func applicationShouldTerminateAfterLastWindowClosed(theApplication: NSApplication) -> Bool {
        return true
    }

    func readInteger(data: NSData, intSize: Int) -> Int? {
        // read integer of intsize length
        var array = [UInt8](count:intSize, repeatedValue: 0)
        if ((data.length-offset) < intSize) {
            return nil
        }
        data.getBytes(&array, range: NSMakeRange(offset, intSize))
        var value: Int = 0
        for a in array {
            value = value * 256 + Int(a)
        }
        offset += intSize
        return value
    }
    
    // read n bytes from manifest.mbdb into subdata and increase offset
    func readBytes(data: NSData) -> NSData? {
        if let datalen = readInteger(data, intSize: 2) {
            if (datalen == 65535 || datalen == 0) {
                //println("special case datalen: \(datalen)")
                return nil
            }
            let subdata: NSData? = data.subdataWithRange(NSMakeRange(offset,datalen))
            offset += datalen
            return subdata
        }
        else {
            return nil
        }
    }

    // Methods for NSComboView
    func numberOfItemsInComboBox(comboBox: NSComboBox) -> Int {
        let numberOfItems: Int = filteredItems.count
        return numberOfItems
    }

    func comboBox(comboBox: NSComboBox, objectValueForItemAtIndex index: Int) -> AnyObject {
        let filteredItem: FileInfo = filteredItems[index]
        return filteredItem.domainString
    }

    // Methodes for NSTableView
    func numberOfRowsInTableView(tableView: NSTableView) -> Int
    {
        let numberOfRows: Int = domainItems.count
        return numberOfRows
    }

    func tableView(tableView: NSTableView, objectValueForTableColumn tableColumn: NSTableColumn?, row: Int) -> AnyObject?
    {
        let domainItem: FileInfo = domainItems[row]
        return domainItem.valueForKey(tableColumn!.identifier)
    }

    @IBAction func tableRowSelected(sender: NSTableView) {
        let selectedRow = sender.selectedRow
        if (domainItems.count > 0) {
            // only if data present
            let backupItem = domainItems[selectedRow]
            if (selectedRow != -1) {
                if (backupItem.type == "= file") {
                    let fileManager = NSFileManager.defaultManager()
                    statusTextView.insertText("filename: \(backupItem.pathIDString), last modified: \(backupItem.mtime)")
                    statusTextView.insertParagraphSeparator(self)
                    let actualFileURL = directoryURL.URLByAppendingPathComponent(backupItem.SHA1)
                    if (fileManager.fileExistsAtPath(actualFileURL.path!)) {
                        let copyFilename = NSString(string: backupItem.pathIDString).lastPathComponent as String
                        // generate File Open Dialog class
                        let copyDlg:NSOpenPanel = NSOpenPanel()
                        copyDlg.title = NSLocalizedString("Select directory for copy", comment: "title of copyPanel")
                        copyDlg.nameFieldStringValue = copyFilename
                        // set path for initial directory
                        copyDlg.directoryURL = userDirectoryURL
                        //copyDlg.allowedFileTypes = ["mbdb"]
                        copyDlg.allowsMultipleSelection = false;
                        copyDlg.canChooseDirectories = true;
                        copyDlg.canCreateDirectories = true;
                        copyDlg.canChooseFiles = false;
                        if (copyDlg.runModal() == NSFileHandlingPanelOKButton) {
                            if let selectedURL = copyDlg.URLs.first {
                                let copyFileURL = selectedURL.URLByAppendingPathComponent(copyFilename, isDirectory: false)
                                do {
                                    try fileManager.copyItemAtURL(actualFileURL, toURL: copyFileURL)
                                    statusTextView.insertText("copy to \(copyFileURL) was successful")
                                    statusTextView.insertParagraphSeparator(self)
                                }
                                catch {
                                    print("copy to \(copyFileURL) failed")
                                }
                            }
                        }
                        else {
                            statusTextView.insertText("no location for copy selected (cancel pressed)")
                            statusTextView.insertParagraphSeparator(self)
                        }
                    }
                    else {
                        statusTextView.insertText("no copy, expected file at \(actualFileURL) doesnt exist")
                        statusTextView.insertParagraphSeparator(self)
                    }
                }
            }
        }
    }

    @IBAction func comboSelected(sender: NSComboBox) {
        let sv = domainComboBox.stringValue
        domainItems = backupItems.filter {$0.domainString == sv}
        if (domainItems.count > 0) {
            let removeFirst = domainItems.removeAtIndex(0)
            if ( !removeFirst.pathIDString.isEmpty ) {
                print("removing first element was not correct !")
            }
            backupTableView.reloadData()
        }
        else {
            statusTextView.insertText("please select a domain item from combobox")
            statusTextView.insertParagraphSeparator(self)
        }
    }

    @IBAction func openSelected(sender: NSButton) {
        // generate File Open Dialog class
        let openDlg:NSOpenPanel = NSOpenPanel()
        openDlg.title = NSLocalizedString("Select Manifest.mbdb file", comment: "title of openPanel")
        let mbdbFile = "Manifest.mbdb"
        openDlg.nameFieldStringValue = mbdbFile
        // set user's directory
        let userDirectoryPath: NSString = "~"
        // set directory where backup files normally live
        userDirectoryURL = NSURL.fileURLWithPath(userDirectoryPath.stringByExpandingTildeInPath)
        openDlg.directoryURL = userDirectoryURL.URLByAppendingPathComponent("Library/Application Support/MobileSync/Backup",
            isDirectory: true)
        openDlg.allowedFileTypes = ["mbdb"]
        openDlg.allowsMultipleSelection = false;
        openDlg.canChooseDirectories = false;
        openDlg.canCreateDirectories = false;
        openDlg.canChooseFiles = true;
        if (openDlg.runModal() == NSFileHandlingPanelOKButton) {
            if let url = openDlg.URLs.first  {
                directoryURL = url.URLByDeletingLastPathComponent!
                statusTextView.insertText("URL = \(url)")
                statusTextView.insertParagraphSeparator(self)
                if let data: NSData? = NSData(contentsOfURL: url) {
                    // reset offset
                    offset = 0
                    // check if a mbdb file was analyzed already
                    if (backupItems.count > 0) {
                        // reset table view
                        backupItems.removeAll(keepCapacity: false)
                        domainItems.removeAll(keepCapacity: false)
                        domainComboBox.stringValue = ""
                        backupTableView.reloadData()
                    }
                    let mbdb = NSData(bytes: [0x6d, 0x62, 0x64, 0x62, 0x05, 0x00] as [UInt8], length: 6)
                    let header: NSData = data!.subdataWithRange(NSMakeRange(offset,6))
                    // offset zum Beginn der eigentlichen Backup-Datei
                    offset += 6
                    if (header.isEqualToData(mbdb)) {
                        // go ahead
                        var i = 0
                        while (offset < data!.length) {
                            var fileInfo: FileInfo = FileInfo()
                            // domain
                            if let d = readBytes(data!) {
                                fileInfo.domain = d
                                // pathID
                                if let p = readBytes(data!) {
                                    fileInfo.pathID = p
                                    fileInfo.SHA1fromData()
                                }
                                fileInfo.infoStrings()
                                // link target
                                if let l = readBytes(data!) {
                                    fileInfo.linkTarget = NSString(data:l, encoding:NSUTF8StringEncoding) as! String
                                    //println("link target: \(fileInfo.linkTarget)")
                                }
                                /*                        else {
                                println("no link target !")
                                }
                                */
                                // data hash
                                let dh = readBytes(data!)
                                /*                        if let dh = readBytes(data!) {
                                println("data hash: \(dh)")
                                }
                                else {
                                println("no data hash !")
                                }
                                */
                                // unknown1
                                let u1 = readBytes(data!)
                                /*                        if let u1 = readBytes(data!) {
                                println("unknown1: \(u1)")
                                }
                                else {
                                println("unknown1 read !")
                                }
                                */
                                // mode
                                if let m = readInteger(data!, intSize: 2) {
                                    //println(String(format: "mode: %04x", m))
                                    switch m & 0xe000 {
                                    case 0x4000:
                                        fileInfo.type = "= directory"
                                        //println("= directory")
                                    case 0x8000:
                                        fileInfo.type = "= file"
                                        //println("= file")
                                    case 0xa000:
                                        fileInfo.type = "= link"
                                        //println("= link")
                                    default:
                                        fileInfo.type = "= unknown filetype"
                                        //println("unknown filetype !")
                                    }
                                }
                                /*
                                else {
                                println("mode gelesen !")
                                }
                                */
                                // unknown2
                                let u2 = readInteger(data!, intSize: 4)
                                /*                        if let u2 = readInteger(data!, 4) {
                                println("unknown2: \(u2)")
                                }
                                else {
                                println("unknown2 read !")
                                }
                                */
                                // unknown3
                                let u3 = readInteger(data!, intSize:4)
                                /*                        if let u3 = readInteger(data!, 4) {
                                println("unknown3: \(u3)")
                                }
                                else {
                                println("unknown3 read !")
                                }
                                */
                                // userid
                                let ui = readInteger(data!, intSize: 4)
                                /*                        if let ui = readInteger(data!, 4) {
                                println("userid: \(ui)")
                                }
                                else {
                                println("no userid !")
                                }
                                */
                                // groupid
                                let gi = readInteger(data!, intSize: 4)
                                /*                        if let gi = readInteger(data!, 4) {
                                println("groupid: \(gi)")
                                }
                                else {
                                println("no groupid !")
                                }
                                */
                                // modify time
                                if let mt = readInteger(data!, intSize: 4) {
                                    fileInfo.mtime = NSDate(timeIntervalSince1970: NSTimeInterval(mt))
                                }
                                /*                        if let mt = readInteger(data!, 4) {
                                println("mtime: \(mt)")
                                }
                                else {
                                println("no mtime !")
                                }
                                */
                                // access time
                                let at = readInteger(data!, intSize: 4)
                                /*                        if let at = readInteger(data!, 4) {
                                println("atime: \(at)")
                                }
                                else {
                                println("no atime !")
                                }
                                */
                                // change time
                                let ct = readInteger(data!, intSize: 4)
                                /*                        if let ct = readInteger(data!, 4) {
                                println("ctime: \(ct)")
                                }
                                else {
                                println("no ctime !")
                                }
                                */
                                // filelen
                                let fl = readInteger(data!, intSize: 8)
                                /*                        if let fl = readInteger(data!, 8) {
                                println("filelen: \(fl)")
                                }
                                else {
                                println("no filelen !")
                                }
                                */
                                // flag and number of properties
                                if let lb = readInteger(data!, intSize: 2) {
                                    let np = lb & 0xff
                                    if (np != 0) {
                                        for _ in 1...np {
                                            var itemProperty = ItemProperty()
                                            //let pn = readBytes(data!)
                                            itemProperty.propertyName = NSString(data:readBytes(data!)!, encoding:NSUTF8StringEncoding) as? String
                                            //println("propname: \(itemProperty.propertyName))")
                                            //let pv = readBytes(data!)
                                            itemProperty.propertyValue = NSString(data:readBytes(data!)!, encoding:NSUTF8StringEncoding) as? String
                                            //println("propvalue: \(itemProperty.propertyValue))")
                                            fileInfo.itemProperties.append(itemProperty)
                                            /*
                                            if let propname = readBytes(data!) {
                                            println("propname: \(propname))")
                                            }
                                            if let propval = readBytes(data!) {
                                            println("propval: \(propval))")
                                            }
                                            */
                                        }
                                        //println("count properties: \(fileInfo.itemProperties.count)")
                                    }
                                }
                                /*
                                else {
                                println("no flag and numprops")
                                }
                                */
                            }
                            else {
                                print("data domain does not exist, processing finished !")
                                break
                            }
                            backupItems.append(fileInfo)
                            i += 1
                        }
                        print("offset: \(offset)")
                        print("count backupitems: \(backupItems.count)")
                        backupTableView.reloadData()
                        // SHA1 is empty only in  case of "naked" domain
                        filteredItems = backupItems.filter {$0.SHA1.isEmpty}
                        // now sort in alphabetical order
                        filteredItems = filteredItems.sort{$0.domainString < $1.domainString}
                        selectTextField.hidden = false
                        domainComboBox.hidden = false
                    }
                    else {
                        print("Does not look like a mbdb file !")
                    }
                }
                else
                {
                    print("File seems not to exist !")
                }
            }
        }
        else {
            print("Cancel Button pressed")
        }
    }
}

